using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using PlainElastic.Net.Utils;

namespace PlainElastic.Net.Queries
{
	/// <summary>
	/// A multi-value metrics aggregation that calculates one or more percentiles over numeric values extracted from the aggregated documents. These values can be extracted either from specific numeric fields in the documents, or be generated by a provided script.
	/// see http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-aggregations-metrics-percentile-aggregation.html
	/// </summary>
	public class PercentilesAggregation<T> : AggregationBase<PercentilesAggregation<T>, T>
	{
		private readonly List<string> aggregationFields = new List<string>();

		/// <summary>
		/// The field to execute percentiles aggregation against.
		/// </summary>
		public PercentilesAggregation<T> Field(string fieldName)
		{
			RegisterJsonPart("'field': {0}", fieldName.Quotate());
			return this;
		}

		/// <summary>
		/// The field to execute percentiles aggregation against.
		/// </summary>
		public PercentilesAggregation<T> Field(Expression<Func<T, object>> field)
		{
			return Field(field.GetPropertyPath());
		}

		/// <summary>
		/// The field to execute percentiles aggregation against.
		/// </summary>
		public PercentilesAggregation<T> FieldOfCollection<TProp>(Expression<Func<T, IEnumerable<TProp>>> collectionField, Expression<Func<TProp, object>> field)
		{
			var collectionProperty = collectionField.GetPropertyPath();
			var fieldName = collectionProperty + "." + field.GetPropertyPath();

			return Field(fieldName);
		}

		/// <summary>
		/// Often, administrators are only interested in outliers — the extreme percentiles. We can specify just the percents we are interested in (requested percentiles must be a value between 0-100 inclusive)
		/// </summary>
		public PercentilesAggregation<T> Percents(params float[] percents) 
		{
			RegisterJsonPart("'percents': [{0}]", string.Join(",", percents));
			return this;
		}

		/// <summary>
		/// Approximate algorithms must balance memory utilization with estimation accuracy. This balance can be controlled using a compression parameter.
		/// </summary>
		public PercentilesAggregation<T> Commpression(int compression)
		{
			RegisterJsonPart("'commpression': {0}", compression.AsString());
			return this;
		}

		/// <summary>
		/// Allow to define a script to evaluate, with its value used to compute the percentiles information.
		/// </summary>
		public PercentilesAggregation<T> Script(string script)
		{
			RegisterJsonPart("'script': {0}", script.Quotate());
			return this;
		}


		/// <summary>
		/// Sets a scripting language used for scripts.
		/// By default used mvel language.
		/// see: http://www.elasticsearch.org/guide/reference/modules/scripting.html
		/// </summary>
		public PercentilesAggregation<T> Lang(string lang)
		{
			RegisterJsonPart("'lang': {0}", lang.Quotate());
			return this;
		}

		/// <summary>
		/// Sets a scripting language used for scripts.
		/// By default used mvel language.
		/// see: http://www.elasticsearch.org/guide/reference/modules/scripting.html
		/// </summary>
		public PercentilesAggregation<T> Lang(ScriptLangs lang)
		{
			return Lang(lang.AsString());
		}

		/// <summary>
		/// Sets parameters used for scripts.
		/// </summary>
		public PercentilesAggregation<T> Params(string paramsBody)
		{
			RegisterJsonPart("'params': {0}", paramsBody);
			return this;
		}

		protected override string ApplyAggregationBodyJsonTemplate(string body)
		{
			return "'percentiles': {{ {0} }}".AltQuoteF(body);
		}

	}
}